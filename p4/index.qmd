---
title: "Practical 4: Routing"
bibliography: ../tds.bib
toc: true
execute: 
  cache: true
  eval: false
editor: 
  markdown: 
    wrap: 72
---

# Introduction

In this practical session, we will learn how to use routing engines and network analysis. The contents of the session are as follows:

* We will start with reviewing the homework from the previous session
* A lecture on graph theory and routing. [Slides here](https://github.com/itsleeds/tds/releases/download/2025/Lecture.4.-.Routing.pptx)
* Practical session on routing in R
* Homework and next session

# Review Homework (20 mins)

Your homework last week was to review some AI written code. Divide into groups of 2-3 people and share the question you asked AI, the code it produced, and the results it got.

* Does the code run first time?
* Do the results answer the question?
* Try modifying the code and the prompt to improve the code generated by the AI.
* Discuss in your groups the strengths and weaknesses of AI written code. 

# Routing Pratical

## Setup

If you have not installed the packages before hand. You can use ITS Go to
do an easy set-up of your computer

```{r, eval=FALSE}
source("https://git.io/JvGjF")
```

The packages we will be using are:

```{r, echo=TRUE, message=FALSE}
library(sf)               # Spatial data functions
library(lwgeom)           # For advanced spatial functions
library(tidyverse)        # General data manipulation
library(stplanr)          # General transport data functions
library(dodgr)            # Local routing and network analysis
library(opentripplanner)  # Connect to and use OpenTripPlanner
library(tmap)             # Make maps
library(osmextract)       # Download and import OpenStreetMap data
tmap_mode("plot")
```

## Using OpenTripPlanner to get routes

We have set up the Multi-modal routing service OpenTripPlanner for West
Yorkshire. Try typing this URL https://otp.robinlovelace.net/ 
during the session into your browser. You should see something like
this:



![](images/otp_screenshot.png)
Note if you see a grey map use the layers button in the top right to switch to a different basemap.


### OTP Web GUI


**Exercise**

1.  Play with the web interface, finding different types of routes. What
    strengths/limitations can you find?

### Connecting to OpenTripPlanner in R

To allow R to connect to the OpenTripPlanner server, we will use the
`opentripplanner` package and the function `otp_connect`.

```{r connect, eval=FALSE}
# ip = "localhost" # to run it on your computer (see final bonus exercise)
ip = "otp.robinlovelace.net" # an actual server
otpcon = otp_connect(hostname = ip, 
                     ssl = TRUE
                     port = 443,
                     router = "west-yorkshire")
```

<!-- Note: the below is for locally hosted OTP: -->

```{r}
#| eval: false
#| echo: false
# Download the zip file
# wget https://github.com/ITSLeeds/TDS/releases/download/0.20.1/otp_TDS.zip
download.file("https://github.com/ITSLeeds/TDS/releases/download/0.20.1/otp_TDS.zip", "otp_TDS.zip")
# Unzip it:
# unzip otp_TDS.zip
unzip("otp_TDS.zip")
# Install Java 8:
system("sudo apt-get install openjdk-8-jdk")

# java –Xmx10000M -d64 -jar "D:/OneDrive - University of Leeds/Data/opentripplanner/otp-1.5.0-shaded.jar" --router west-yorkshire --graphs "D:/OneDrive - University of Leeds/Data/opentripplanner/graphs" --server --port 8080 --securePort 8081
```

```{bash}
#| echo: false
#| eval: false
# Run it without nohup to test:
/usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java -Xmx10000M -d64 -jar "otp_TDS/otp-1.5.0-shaded.jar" --router west-yorkshire --graphs "otp_TDS/graphs" --server --port 8090 --securePort 8091


# Same command but with nohup to run in the background:
nohup /usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java -Xmx10000M -d64 -jar "otp_TDS/otp-1.5.0-shaded.jar" --router west-yorkshire --graphs "otp_TDS/graphs" --server --port 8090 --securePort 8091 &
```

If you have connected successfully, then you should get a message “Router exists.”


Create a test route. Notice than in the web UI the coordinates are `Lat/Lng` but R uses `Lng/Lat`

```{r testroute, eval=FALSE, message=FALSE, warning=FALSE}
routes_test = otp_plan(otpcon = otpcon,
                            fromPlace = c(-1.55555, 53.81005), #Lng/Lat
                            toPlace = c(-1.54710, 53.79519),
                            mode = "WALK") 
```
You can use multiple modes and combinations try:

* `mode = "WALK"`
* `mode = c("WALK","TRANSIT")`
* `mode = c("BICYCLE","TRANSIT")`
* `mode = "CAR"`
* `mode = c("CAR_PARK","TRANSIT")`

Use some of the functions you have already learnt like `head`,`plot`, and `summary` to understand the data you have produced.

To get some more routes, we will start by importing some data. The `NTEM_flow.geojson` dataset the contains the top desire lines in West Yorkshire. It was produced from a transport model called the [National Trip End Model](https://data.gov.uk/dataset/11bc7aaf-ddf6-4133-a91d-84e6f20a663e/national-trip-end-model-ntem) and research from the [University of Leeds](https://github.com/ITSLeeds/NTEM2OD).


```{r loaddesirelines, message=FALSE}
u = "https://github.com/ITSLeeds/TDS/releases/download/22/NTEM_flow.geojson"
desire_lines = read_sf(u)
head(desire_lines)
```


We will also download the points that represent the possible start and end point of trips in the model

```{r loadcentroids, message=FALSE}
u = "https://github.com/ITSLeeds/TDS/releases/download/22/NTEM_cents.geojson"
centroids = read_sf(u)
head(centroids)
```
**Exercise** 

2. Plot the `desire_lines` and `centroids` objects using the `tmap` package to show the number of travellers on each desire_line and the locations of all centroids.

```{r, message=FALSE, echo=TRUE}
tmap_mode("plot") # Change to view for interactive map
tm_shape(desire_lines) +
  tm_lines(col = "all",
           lwd = "all",  
           lwd.scale = tm_scale_continuous(values.scale = 10), 
           col.scale = tm_scale_continuous(values  = "-viridis")) +
  tm_shape(centroids) +
  tm_dots(fill = "red")
```


3. Produce some different maps for each mode of travel in the `desire_lines` dataset. How do the numbers of travellers change for walking, driving, and train travel? See example plot below.


```{r, message=FALSE, echo=FALSE}
tmap_mode("plot") # Change to view for interactive map
tm_shape(desire_lines) +
  tm_lines(lwd = "rail", 
           col = "rail",
           lwd.scale = tm_scale_continuous(values.scale = 10), 
           col.scale = tm_scale_continuous(values  = "-viridis"))
```

This dataset has desire lines, but most routing packages need start and endpoints, so we will extract the start and endpoints using the package `lwgeom`


**Exercise**

4. Produce a data frame called `desire_top` which contains the top three `desire_lines` for all travellers. Hint `?slice_max`

```{r, echo=FALSE}
desire_top = desire_lines %>% 
  slice_max(order_by = all,n = 3)
```


5. We need to extract start and end point from those desire lines. We would also like to give each place an ID value

```{r, echo=TRUE}
# Extract the start and end points
fromPlace = lwgeom::st_startpoint(desire_top)
toPlace = lwgeom::st_endpoint(desire_top)

# This returns just the geometry
# So make it into an sf data.frame with the ID values from desire_top

fromPlace = st_sf(data.frame(id = desire_top$from, geometry = fromPlace))
toPlace = st_sf(data.frame(id = desire_top$to, geometry = toPlace))
```


6. Create a new object called `routes_drive_top`, with driving routes between the OD pairs represented in the `desire_top` object. 


Calculate routes for the first three desire lines with the following command:

```{r, message=FALSE,  eval=FALSE}
routes_drive_top = otp_plan(otpcon = otpcon,
                            fromPlace = fromPlace,
                            toPlace = toPlace,
                            fromID = fromPlace$id,
                            toID = toPlace$id,
                            mode = "CAR")
```

```{r, message=FALSE,  echo=FALSE}
# Save as RDS:
# saveRDS(routes_drive_top, "routes_drive_top.Rds")
# piggyback::pb_upload("routes_drive_top.Rds")
# Download the file.
# files = piggyback::pb_list()
# Search for the file:
# files = files[grepl("routes_drive_top", files$file_name),]
# u = piggyback::pb_download_url("routes_drive_top.Rds")
u = "https://github.com/ITSLeeds/TDS/releases/download/23/routes_drive_top.Rds"
f = basename(u)
if (!file.exists(f)) download.file(u, f, mode = "wb")
routes_drive_top = readRDS("routes_drive_top.Rds")
```


7. Plot `routes_drive_top` using the `tmap` package mode. You should see something like the image below.

```{r, echo=FALSE, message=FALSE}
tmap_mode("plot")
```

```{r}
tm_shape(routes_drive_top) + tm_lines()
```

### Isochrones

We can also get Isochrones from OTP. In this case lets work out how far we can travel in one hour by cycling and public transport.

```{r, message=FALSE, eval=FALSE}
isochrone = otp_isochrone(otpcon, 
                          fromPlace = c(-1.558655, 53.807870), 
                          mode = c("BICYCLE","TRANSIT"),
                          maxWalkDistance = 3000)
isochrone$time = isochrone$time / 60 # Convert from seconds to minutes
tm_shape(isochrone) +
  tm_fill("time", alpha = 0.6)
```

Experiment with some different isochrones by changing the mode, and start location. Ty overlaying the OD data on top of you isochrones. Can you see a relationship between travel time and travel demand?

```{r, message=FALSE, eval=FALSE, echo=FALSE}
# Save the isochrone as RDS
saveRDS(isochrone, "isochrone.Rds")
piggyback::pb_upload("isochrone.Rds")
```


```{r, message=FALSE, echo=FALSE}
u = "https://github.com/ITSLeeds/TDS/releases/download/23/isochrone.Rds"
if (!file.exists("isochrone.Rds")) download.file(u, "isochrone.Rds", mode = "wb")
```

```{r, message=FALSE, echo=FALSE}
if (file.exists("isochrone.Rds")){isochrone = readRDS("isochrone.Rds")}
if (file.exists("p4/isochrone.Rds")){isochrone = readRDS("p4/isochrone.Rds")}
isochrone = readRDS("isochrone.Rds")
isochrone$time = isochrone$time / 60
tm_shape(isochrone) +
  tm_fill("time", alpha = 0.6)
```


To save you time and to prevent overloading the server, we have pre-generated some extra routes. Download these routes and load them into R.

```{r, message=FALSE, eval=FALSE, echo=FALSE}
routes_drive = route(l = desire_lines, route_fun = otp_plan, otpcon = otpcon, mode = "CAR")
# fromPlace = centroids[match(desire_lines$from, centroids$Zone_Code),]
# toPlace = centroids[match(desire_lines$to, centroids$Zone_Code),]
# routes_drive = otp_plan(otpcon = otpcon,
#                             fromPlace = fromPlace,
#                             toPlace = toPlace,
#                             fromID = fromPlace$Zone_Code,
#                             toID = toPlace$Zone_Code,
#                             mode = "CAR",
#                             ncores = 20)

sf::write_sf(routes_drive, "routes_drive.geojson", delete_dsn = TRUE)
piggyback::pb_upload("routes_drive.geojson")

date_time = lubridate::ymd_hms("2022-01-25 09:00:00") 
routes_transit = route(
  l = desire_lines, route_fun = otp_plan, otpcon = otpcon,
  mode = c("WALK","TRANSIT"), date_time = date_time, maxWalkDist = 2000
  )

# routes_transit = otp_plan(otpcon = otpcon,
#                             fromPlace = fromPlace,
#                             toPlace = toPlace,
#                             fromID = fromPlace$Zone_Code,
#                             toID = toPlace$Zone_Code,
#                             mode = c("WALK","TRANSIT"),
#                             date_time = date_time,
#                             ncores = 20,
#                             maxWalkDistance = 2000)
summary(st_is_valid(routes_transit))
routes_transit = st_make_valid(routes_transit)
sf::write_sf(routes_transit, "routes_transit.geojson", delete_dsn = TRUE)
piggyback::pb_upload("routes_transit.geojson")
```

```{r, message=FALSE, echo=TRUE}
u = "https://github.com/ITSLeeds/TDS/releases/download/22/routes_drive.geojson"
routes_drive = read_sf(u)
u = "https://github.com/ITSLeeds/TDS/releases/download/22/routes_transit.geojson"
routes_transit = read_sf(u)
```

We will now join the number of drivers onto the driving routes.

**Exercise**

8. Create a dataset called `n_driver` from `desire_lines` which only have the columns `from` `to` and `drive`. Hint `?dplyr::select`  and `?sf::st_drop_geometry`

```{r, message=FALSE, echo=FALSE}
n_driver = desire_lines %>%
  st_drop_geometry() %>%
  select(from, to, drive)
```

9. Join the `n_driver` data onto the `routes_drive` data by linking `fromPlace = from` and `toPlace = to`. Hint `?dplyr::left_join`.

```{r, message=FALSE, echo=FALSE}
routes_drive = left_join(routes_drive, n_driver, by = c("fromPlace" = "from","toPlace" = "to"))
```

10. Plot the routes showing the number of drivers on each route.

```{r, message=FALSE, echo=FALSE}
tm_shape(routes_drive) +
  tm_lines(col = "drive", 
           lwd = 2, 
           col.scale = tm_scale_continuous(values  = "-viridis"))
```

## Route Networks (also called flow maps)

The map above shows some useful information about where people drive. But it has a problem. When many routes overlap it hides some of the drivers. What would be more useful would be to add those drivers together so we can see the total number of drivers on each road. This is what a route network does.

We can produce a route network map using `stplanr::overline`.

```{r, message=FALSE, echo=TRUE}
rnet_drive = overline(routes_drive, "drive")
```

**Exercise**

10. Make a route network for driving and plot it using the `tmap` package. How is is different from just plotting the routes?

```{r, message=FALSE, echo=FALSE}
tm_shape(rnet_drive) +
  tm_lines(lwd = 2, 
           col = "drive", 
           col.scale = tm_scale_intervals(values  = "-viridis", style = "jenks"))
```

**Bonus Exercise**

* Read the [paper](https://journals.sagepub.com/doi/10.1177/2399808320942779) about the overline function.

### Line Merging

Notice that `routes_transit` has returned separate rows for each mode (WALK, RAIL, BUS). Notice the `route_option` column shows that some routes have multiple options.

Let's suppose you want a single line for each route.

**Exercise**

11. Filter the `routes_transit` to contain only one route option per origin-destination pair and only the columns `fromPlace` `toPlace` `distance` `geometry`. Hint `filter()` and `select`


```{r, message=FALSE, echo=FALSE}
routes_transit = routes_transit |>
  filter(route_option == 1) |>
  select(fromPlace, toPlace, distance)
```


Now We will group the separate parts of the routes together.

```{r, message=FALSE}
routes_transit_group = routes_transit |>
  dplyr::group_by(fromPlace, toPlace) |>
  dplyr::summarise(distance = sum(distance))
```

We now have a single row, but instead of a `LINESTRING`, we now have a mix of `MULTILINESTRING` and `LINESTRING`, we can convert to a `LINESTRING` by using `st_line_merge()`. Note how the different columns where summarised.


First, we must separate out the `MULTILINESTRING` and `LINESTRING`

```{r, eval=FALSE}
routes_transit_group_ml = routes_transit_group[st_geometry_type(routes_transit_group) == "MULTILINESTRING", ]
routes_transit_group = routes_transit_group[st_geometry_type(routes_transit_group) != "MULTILINESTRING", ]
routes_transit_group_ml = st_line_merge(routes_transit_group_ml)
routes_transit_group = rbind(routes_transit_group, routes_transit_group_ml)
```

**Exercise**

12. Plot the transit routes, what do you notice about them?

```{r, message=FALSE, echo=FALSE}
tm_shape(routes_transit_group) +
  tm_lines(lwd = 2, col = "black")
```


**Bonus Exercise**: 

13. Redo exercise 16 but make sure you always select the fastest option. You may need to re-download the `routes_transit` data if you have overwritten the original data.

## Network Analysis (dodgr)

**Note** Some people have have problems running dodgr on Windows, if you do follow these [instructions](https://github.com/itsleeds/tds/blob/master/practicals/dodgr-install.md).

We will now analyse the road network using `dodgr`. Network analysis can take a very long time on large areas. So we will use the example of the [Isle of Wight](https://en.wikipedia.org/wiki/Isle_of_Wight), which is ideal for transport studies as it is small, but has a full transport system including a railway and the last commercial hovercraft service in the world.


First we need to download the roads network from the OpenStreetMap using `osmextract::oe_get`. We will removed most of the paths and other features and just focus on the main roads. Then use `dodgr::weight_streetnet` to produce a graph of the road network.

```{r, warning=FALSE, message=FALSE, results='hide'}
# Download data from OpenSteetMap
roads = oe_get("Isle of Wight", extra_tags = c("maxspeed","oneway"))

# Remove non-road data
roads = roads[!is.na(roads$highway),]

# Only get some road types see https://wiki.openstreetmap.org/wiki/Key:highway
road_types = c("primary","primary_link",
               "secondary","secondary_link",
               "tertiary", "tertiary_link",
               "residential","unclassified")
roads = roads[roads$highway %in% road_types, ]

# Build a graph
graph = weight_streetnet(roads)
```


We will find the [betweenness centrality](https://en.wikipedia.org/wiki/Betweenness_centrality) of the Isle of Wight road network. This can take a long time, so first lets check how long it will take. 

```{r, message=TRUE, echo=TRUE}
estimate_centrality_time(graph)
centrality = dodgr_centrality(graph)
```


We can convert a `dodgr` graph back into a sf data frame for plotting using `dodgr::dodgr_to_sf`


```{r, message=FALSE, echo=TRUE, results='hide', warning=FALSE}
clear_dodgr_cache()
centrality_sf = dodgr_to_sf(centrality)
```

**Exercise**

14. Plot the centrality of the Isle of Wight road network. What can centrality tell you about a road network?

```{r, message=TRUE, echo=FALSE}
tm_shape(centrality_sf) +
  tm_lines(col = "centrality",
           lwd = 3,
           col.scale = tm_scale_intervals(n = 8, values  = "-viridis", style = "fisher"))
```


15. Use `dodgr::dodgr_contract_graph` before calculating centrality, how does this affect the computation time and the results?

**Bonus Exercises**

16. Work though the OpenTripPlanner vignettes [Getting Started](https://docs.ropensci.org/opentripplanner/articles/opentripplanner.html) and [Advanced Features](https://docs.ropensci.org/opentripplanner/articles/advanced_features.html) to run your own local trip planner for the Isle of Wight.

**Note** To use OpenTripPlanner on your own computer requires Java 8. See the [Prerequisites](https://docs.ropensci.org/opentripplanner/articles/prerequisites.html) for more details. If you can't install Java 8 try some of the examples in the vignettes but modify them for West Yorkshire.

17. Read the `dodgr` [vignettes](https://urbananalyst.github.io/dodgr/articles/index.html)

18. Read the [MinorRoadTraffic](https://github.com/ITSLeeds/MinorRoadTraffic) [vignette](https://github.com/itsleeds/MinorRoadTraffic/blob/main/vignettes/Oxford.md) this is a Masters Dissertation topic where students attempt to predict traffic levels using network analysis. The vignette and the package contain some examples of Transport Data Science in action.

# Homework

Prepare you [draft portfolio](https://itsleeds.github.io/tds/d2/) for submission on the 28th February.


